# 问题描述：

正常场景中音乐和导航同时出现的场景一般以应用监听AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK这个做下降低音量处理即可，但是车机场景中，BT播放音乐只请求音频焦点，未生成player，duck无法监听playevent状态，checkDuck失败,log如下：

```shell
M00D859  10-12 19:49:44.292  4329  5448 V MediaFocusControl: NOT dispatching LOSS_TRANSIENT_CAN_DUCK to android.media.AudioManager@c8baad4com.android.bluetooth.a2dpsink.A2dpSinkStreamHandler$1@97c847d, ducking implemented by framework
```

# 分析和修改：

Ø在Android 8.0 (API 26)后，当另一个应用程序使用AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK请求焦点时，不会触发本应用的onAudioFocusChange()回调，而是交给系统做duckplayer处理；

Øa2dp_seek直接通过native的AudioTrack播放，AudioServie获取不到当前所需要player的id和状态，所以无法通过系统duckPlayers来管理当下的场景；

Øworkround方案，在高德等应用申请AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK时，如果当前音频焦点在bt A2dpSinkStreamHandler上，则不走系统duckpalyer流程，通过分发focusChange到应用，bt应用监听收到CAN DUCK消息主动降低音量;

```java
diff --git a/services/core/java/com/android/server/audio/FocusRequester.java b/services/core/java/com/android/server/audio/FocusRequester.java
index db55138..ad5874f 100644
--- a/services/core/java/com/android/server/audio/FocusRequester.java
+++ b/services/core/java/com/android/server/audio/FocusRequester.java
@@ -381,6 +381,14 @@
                             // legacy behavior, apps used to be notified when they should be ducking
                             handled = false;
                             Log.v(TAG, "not ducking uid " + this.mCallingUid + " - old SDK");
+                        //fixed 1393896 for notifying bt do ducking byself start
+                        } else if (!forceDuck &&  null != mClientId && mClientId.contains("com.android.bluetooth.a2dpsink.A2dpSinkStreamHandler")) {
+                            handled = false;
+                            if (DEBUG) {
+                                Log.v(TAG, "dispatching " + focusChangeToString(mFocusLossReceived) + " to "
+                                        + mClientId + ",ducking by BT!");
+                            }
+                        //fixed 1393896 for notifying bt do ducking byself end
                         } else {
                             handled = mFocusController.duckPlayers(frWinner, this, forceDuck);
                         }

```

# AudioFocus流程

![image-20210830143637372](C:\Users\hursion.zhang\AppData\Roaming\Typora\typora-user-images\image-20210830143637372.png)

## android AudioFocus的使用

1.获取AudioManager对象

2.实现AudioFocusChangeListener接口

3.构造AudioFocusRequest对象

4.调用audioManager.requestAudioFocus方法来获取焦点并处理结果

## 获取音频焦点durationHint可能的结果，

其中GAIN有4种

•AUDIOFOCUS_GAIN 永久获取焦点

•AUDIOFOCUS_GAIN_TRANSIENT 临时获取焦点

•AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK 临时获取焦点，其它应用可以降低音量

•AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE 临时获取焦点，不会让出

LOSS有3种

•AUDIOFOCUS_LOSS 永久失去焦点

•AUDIOFOCUS_LOSS_TRANSIENT 临时失去焦点

•AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK 临时失去焦点，可以不静音